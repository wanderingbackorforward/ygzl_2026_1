// 裂缝监测图表绘制脚本
document.addEventListener('DOMContentLoaded', function() {
    // 初始化所有图表
    initCharts();
    
    // 绑定上传按钮事件
    document.getElementById('upload-button').addEventListener('click', showUploadModal);
    document.getElementById('select-file-btn').addEventListener('click', function() {
        document.getElementById('file-input').click();
    });
    
    // 绑定文件选择事件
    document.getElementById('file-input').addEventListener('change', handleFileSelect);
    
    // 绑定文件上传事件
    document.getElementById('upload-file-btn').addEventListener('click', uploadFile);
    
    // 绑定模态框关闭按钮
    document.querySelector('.close').addEventListener('click', function() {
        document.getElementById('upload-modal').style.display = 'none';
    });
    
    // 绑定拖放区域事件
    const dropArea = document.getElementById('drop-area');
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        dropArea.addEventListener(eventName, preventDefaults, false);
    });
    
    function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
    }
    
    ['dragenter', 'dragover'].forEach(eventName => {
        dropArea.addEventListener(eventName, highlight, false);
    });
    
    ['dragleave', 'drop'].forEach(eventName => {
        dropArea.addEventListener(eventName, unhighlight, false);
    });

    function highlight() {
        dropArea.classList.add('highlight');
    }

    function unhighlight() {
        dropArea.classList.remove('highlight');
    }

    dropArea.addEventListener('drop', handleDrop, false);
});

// 全局变量存储图表实例
let charts = {
    trend: null,
    overview: null,
    daily: null,
    mainTrend: null,
    slope: null,
    rate: null,
    correlation: null
};

// 全局变量存储监测点数据
let monitoringPoints = [];
let crackData = { series: [], dates: [] }; // Initialize crackData

// 修改后的初始化所有图表函数
function initCharts() {
    console.log('开始初始化图表...');

    fetchMonitoringPoints()
        .then(() => {
            // Populate the multi-select dropdown for the main trend chart
            populateMainTrendSelect();
            return fetchCrackData();
        })
        .then(() => {
            console.log('数据获取完成，开始初始化图表');
            return initTrendChartSafely()
                .then(() => delay(100))
                .then(() => initOverviewChartSafely())
                .then(() => delay(100))
                .then(() => initDailyChartSafely())
                .then(() => delay(100))
                .then(() => initMainTrendChartSafely()) // Will call updateMainTrendChart internally
                .then(() => delay(100))
                .then(() => initSlopeChartSafely())
                .then(() => delay(100))
                .then(() => initRateChartSafely())
                .then(() => delay(100))
                .then(() => initCorrelationChartSafely());
        })
        .then(() => {
            console.log('所有图表初始化完成');
            updateDataTable();
            setupChartZoom(charts);
            // Add event listener for the main trend refresh button AFTER charts are initialized
            addMainTrendRefreshListener();
        })
        .catch(error => {
            console.error('初始化图表失败:', error);
            showNotification('初始化图表失败，请检查数据是否已导入', 'error');
        });

    // 辅助函数：延迟执行
    function delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    // 安全初始化函数 - 为每个图表添加错误处理
    function initTrendChartSafely() {
        return new Promise((resolve) => {
            try {
                initTrendChart();
                console.log('趋势图初始化成功');
            } catch (e) {
                console.error('趋势图初始化失败:', e);
            }
            resolve();
        });
    }

    function initOverviewChartSafely() {
        return new Promise((resolve) => {
            try {
                initOverviewChart();
                console.log('概览图初始化成功');
            } catch (e) {
                console.error('概览图初始化失败:', e);
            }
            resolve();
        });
    }

    function initDailyChartSafely() {
        return new Promise((resolve) => {
            try {
                initDailyChart();
                console.log('日变化率图初始化成功');
            } catch (e) {
                console.error('日变化率图初始化失败:', e);
            }
            resolve();
        });
    }

    function initMainTrendChartSafely() {
        return new Promise((resolve) => {
            try {
                initMainTrendChart(); // Initializes the chart structure
                console.log('主趋势图初始化成功 (结构)');
            } catch (e) {
                console.error('主趋势图初始化失败:', e);
            }
            resolve();
        });
    }

    function initSlopeChartSafely() {
        return new Promise((resolve) => {
            try {
                // Use existing simplified slope chart initialization
                initSlopeChart(); // Call the existing function
                console.log('斜率趋势图初始化成功');
            } catch (e) {
                console.error('斜率趋势图初始化失败:', e);
            }
            resolve();
        });
    }

    function initRateChartSafely() {
        return new Promise((resolve) => {
            try {
                initRateChart();
                console.log('平均变化率图初始化成功');
            } catch (e) {
                console.error('平均变化率图初始化失败:', e);
            }
            resolve();
        });
    }

    function initCorrelationChartSafely() {
        return new Promise((resolve) => {
            try {
                initCorrelationChart();
                console.log('相关性图初始化成功');
            } catch (e) {
                console.error('相关性图初始化失败:', e);
            }
            resolve();
        });
    }
}

// Populate the main trend chart select dropdown
function populateMainTrendSelect() {
    const selectElement = document.getElementById('main-trend-select');
    if (!selectElement) {
        console.error('无法找到 main-trend-select 元素');
        return;
    }
    selectElement.innerHTML = ''; // Clear existing options
    if (monitoringPoints && monitoringPoints.length > 0) {
        monitoringPoints.forEach(point => {
            const option = document.createElement('option');
            option.value = point.point_id;
            option.textContent = point.point_id;
            selectElement.appendChild(option);
        });
        console.log('主趋势图监测点下拉列表已填充');

        // Add listener to limit selection to 5
        selectElement.addEventListener('change', () => {
            const selectedOptions = Array.from(selectElement.selectedOptions);
            if (selectedOptions.length > 5) {
                showNotification('最多只能选择 5 个监测点', 'warning');
                // Deselect the last selected item to enforce limit
                const lastSelected = selectedOptions[selectedOptions.length - 1];
                 if (lastSelected) {
                    lastSelected.selected = false;
                }
                 // Re-check and ensure only 5 are selected (might need better logic if deselecting fails)
                 const currentSelected = Array.from(selectElement.selectedOptions);
                 if (currentSelected.length > 5) {
                    // Force deselect extra ones if the above didn't work reliably
                    for (let i = 5; i < currentSelected.length; i++) {
                        currentSelected[i].selected = false;
                    }
                 }
            }
        });

    } else {
        console.warn('无监测点数据，无法填充下拉列表');
    }
}

// Add event listener for the main trend refresh button
function addMainTrendRefreshListener() {
    const refreshButton = document.getElementById('main-trend-refresh-btn');
    const selectElement = document.getElementById('main-trend-select');

    if (refreshButton && selectElement) {
        refreshButton.addEventListener('click', () => {
            const selectedOptions = Array.from(selectElement.selectedOptions);
            if (selectedOptions.length === 0) {
                showNotification('请至少选择一个监测点', 'warning');
                return;
            }
            if (selectedOptions.length > 5) {
                showNotification('最多只能选择 5 个监测点', 'error');
                return; // Should be prevented by the change listener, but double-check
            }
            const selectedPointIds = selectedOptions.map(option => option.value);
            console.log('更新主趋势图，选择的点:', selectedPointIds);
            updateMainTrendChart(selectedPointIds);
        });
        console.log('主趋势图刷新按钮监听器已添加');
    } else {
        console.error('无法找到主趋势图刷新按钮或选择框');
    }
}

// 获取监测点数据
function fetchMonitoringPoints() {
    return fetch('/api/crack/monitoring_points')
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                monitoringPoints = data.data;
                console.log('获取监测点数据成功:', monitoringPoints);
            } else {
                console.error('获取监测点数据失败:', data.message);
                monitoringPoints = []; // Ensure it's an empty array on failure
                throw new Error(data.message);
            }
        })
        .catch(error => {
            console.error('Fetch monitoring points error:', error);
            monitoringPoints = []; // Ensure empty array on network error too
            throw error; // Re-throw to be caught by initCharts
        });
}

// 获取裂缝数据
function fetchCrackData() {
    return fetch('/api/crack/trend_data')
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success' && data.data && Array.isArray(data.data.series) && Array.isArray(data.data.dates)) {
                crackData = data.data;
                console.log('获取裂缝数据成功:', crackData);
            } else {
                console.error('获取裂缝数据失败或格式无效:', data.message || '格式无效');
                 crackData = { series: [], dates: [] }; // Reset to empty structure
                throw new Error(data.message || '获取裂缝数据失败');
            }
        })
        .catch(error => {
            console.error('Fetch crack data error:', error);
            crackData = { series: [], dates: [] }; // Reset to empty structure
            throw error; // Re-throw
        });
}

// 初始化总体趋势图 (修改为平均趋势+范围)
function initTrendChart() {
    const chartElement = document.getElementById('chart-trend');
    if (!chartElement) {
        console.error('无法找到 chart-trend 元素');
        return;
    }
    const chart = echarts.init(chartElement);

    if (!crackData || !crackData.dates || crackData.dates.length === 0 || !crackData.series || crackData.series.length === 0) {
        console.warn('无裂缝数据，无法初始化平均趋势图');
        chart.setOption({ title: { text: '无趋势数据', left: 'center', top: 'center' } });
        charts.trend = chart;
        return;
    }

    const dates = crackData.dates;
    const seriesCount = crackData.series.length;
    const dataLength = dates.length;
    const aggregatedData = [];

    for (let i = 0; i < dataLength; i++) {
        const valuesAtTime = [];
        for (let j = 0; j < seriesCount; j++) {
            const value = crackData.series[j].data[i];
            if (value !== null && value !== undefined && !isNaN(value)) {
                valuesAtTime.push(value);
            }
        }

        if (valuesAtTime.length > 0) {
            const sum = valuesAtTime.reduce((a, b) => a + b, 0);
            const avg = sum / valuesAtTime.length;
            const min = Math.min(...valuesAtTime);
            const max = Math.max(...valuesAtTime);
            aggregatedData.push({ date: dates[i], avg: avg, min: min, max: max });
        } else {
            aggregatedData.push({ date: dates[i], avg: null, min: null, max: null });
        }
    }

    const avgValues = aggregatedData.map(item => item.avg);
    // For range area chart, we need [min, max] pairs
    const rangeValues = aggregatedData.map(item => (item.min !== null && item.max !== null) ? [item.min, item.max] : [null, null]);

    const option = {
        tooltip: {
            trigger: 'axis',
            formatter: function(params) {
                if (!params || params.length === 0) return '';
                const date = params[0].axisValue;
                let result = date + '<br/>';
                const avgParam = params.find(p => p.seriesName === '平均宽度');
                const rangeParam = params.find(p => p.seriesName === '范围');

                if (avgParam && avgParam.value !== null && !isNaN(avgParam.value)) {
                    result += avgParam.marker + ' 平均宽度: ' + avgParam.value.toFixed(3) + ' mm<br/>';
                }
                if (rangeParam && rangeParam.value && rangeParam.value[0] !== null && rangeParam.value[1] !== null) {
                    result += rangeParam.marker + ' 范围: ' + rangeParam.value[0].toFixed(3) + ' - ' + rangeParam.value[1].toFixed(3) + ' mm';
                }
                return result;
            }
        },
        legend: {
            data: ['平均宽度', '范围'],
            bottom: 10,
            textStyle: { fontSize: 14, color: '#cccccc' } // Use light grey
        },
        grid: {
            left: '8%',
            right: '5%',
            bottom: '18%', // Adjust bottom for legend
            top: '12%',
            containLabel: true
        },
        xAxis: {
            type: 'category',
            boundaryGap: false,
            data: dates,
            axisLabel: {
                fontSize: 12
            }
        },
        yAxis: {
            type: 'value',
            name: '裂缝宽度(mm)',
            nameTextStyle: { fontSize: 14 },
            axisLabel: { fontSize: 12 }
        },
        series: [
            {
                name: '范围',
                type: 'line',
                data: rangeValues, // Data in [min, max] format
                lineStyle: { opacity: 0 }, // Hide the line itself
                stack: 'range_stack', // Use stack to draw area between min and max
                symbol: 'none',
                areaStyle: {
                    color: 'rgba(0, 229, 255, 0.15)' // Slightly less intense range color
                },
                tooltip: { // Custom tooltip for range if needed, or rely on main tooltip
                    formatter: function(param) {
                         if (param.value && param.value[0] !== null) {
                            return `范围: ${param.value[0].toFixed(3)} - ${param.value[1].toFixed(3)} mm`;
                         }
                         return '';
                    }
                }
            },
             // Need a dummy series stacked below the range for the area fill to work correctly
            {
                name: '范围基线', // Dummy series
                type: 'line',
                stack: 'range_stack', // Same stack name
                symbol: 'none',
                lineStyle: { opacity: 0 },
                areaStyle: { opacity: 0 }, // Make its area invisible
                data: rangeValues.map(pair => pair[0]) // Plot the 'min' value
            },
            {
                name: '平均宽度',
                type: 'line',
                data: avgValues,
                connectNulls: false,
                showSymbol: false,
                lineStyle: {
                    width: 2,
                    color: '#ffffff' // Change average line to white
                }
            }
        ]
    };

    chart.setOption(option, true); // Use true to replace existing options
    charts.trend = chart;

    window.addEventListener('resize', function() {
        if (charts.trend && !charts.trend.isDisposed()) {
            charts.trend.resize();
        }
    });
}

// 初始化统计概览图
function initOverviewChart() {
    const chart = echarts.init(document.getElementById('chart-overview'));

    const changeTypeCounts = {
        '扩展': 0,
        '收缩': 0,
        '稳定': 0,
        '数据不足': 0
    };

    monitoringPoints.forEach(point => {
        // Use '未知' if change_type is null or undefined
        const type = point.change_type || '数据不足';
        if (type in changeTypeCounts) {
            changeTypeCounts[type]++;
        } else { // Should not happen if initialized correctly, but safer
             changeTypeCounts['数据不足']++;
        }
    });

    const pieData = Object.keys(changeTypeCounts).map(key => ({
        name: key,
        value: changeTypeCounts[key]
    })).filter(item => item.value > 0); // Only show types with count > 0

    const option = {
        tooltip: {
            trigger: 'item',
            formatter: '{a} <br/>{b} : {c} ({d}%)'
        },
        legend: {
            orient: 'vertical',
            left: 'left',
            data: pieData.map(item => item.name),
            textStyle: { fontSize: 18 } // Increased from 14
        },
        series: [
            {
                name: '变化类型',
                type: 'pie',
                radius: '60%',
                center: ['50%', '50%'],
                data: pieData,
                emphasis: {
                    itemStyle: {
                        shadowBlur: 10,
                        shadowOffsetX: 0,
                        shadowColor: 'rgba(0, 0, 0, 0.5)'
                    },
                    label: {
                        show: true,
                        fontSize: 20, // Increased from 18
                        fontWeight: 'bold'
                    }
                },
                itemStyle: {
                    color: function(params) {
                        const colors = {
                            '扩展': '#c23531',
                            '收缩': '#2f4554',
                            '稳定': '#61a0a8',
                            '未知': '#d48265',
                            '数据不足': '#999999'
                        };
                        return colors[params.name] || '#91c7ae';
                    }
                }
            }
        ]
    };

    chart.setOption(option);
    charts.overview = chart;

    window.addEventListener('resize', function() {
        if (charts.overview && !charts.overview.isDisposed()) {
            charts.overview.resize();
        }
    });
}

// 初始化日变化率图 (修改为直方图)
function initDailyChart() {
    const chartElement = document.getElementById('chart-daily');
    if (!chartElement) {
        console.error('无法找到 chart-daily 元素');
        return;
    }
    const chart = echarts.init(chartElement);

    let dailyRates = [];
    if (monitoringPoints && monitoringPoints.length > 0) {
        dailyRates = monitoringPoints
            .map(point => point.average_change_rate)
            .filter(rate => rate !== null && typeof rate === 'number' && !isNaN(rate));
    } else {
         console.warn('无监测点数据，无法初始化日变化率直方图');
         chart.setOption({ title: { text: '无日变化率数据', left: 'center', top: 'center' } });
         charts.daily = chart;
         return;
    }

    if (dailyRates.length === 0) {
        console.warn('过滤后无有效的日变化率数据');
        chart.setOption({ title: { text: '无有效日变化率数据', left: 'center', top: 'center' } });
        charts.daily = chart;
        return;
    }

    // Determine reasonable bins for the histogram
    const minRate = Math.min(...dailyRates);
    const maxRate = Math.max(...dailyRates);
    const range = maxRate - minRate;
    // Aim for roughly 10-15 bins, adjust binWidth accordingly
    let binCount = Math.max(5, Math.min(15, Math.ceil(Math.sqrt(dailyRates.length))));
    let binWidth = range / binCount;

    // Make binWidth a 'nice' number if possible (e.g., 0.01, 0.005)
    if (binWidth > 0) {
        const magnitude = Math.pow(10, Math.floor(Math.log10(binWidth)));
        const res = binWidth / magnitude;
        if (res < 1.5) binWidth = 1 * magnitude;
        else if (res < 3.5) binWidth = 2 * magnitude;
        else if (res < 7.5) binWidth = 5 * magnitude;
        else binWidth = 10 * magnitude;
         binCount = Math.ceil(range / binWidth);
    } else {
        binWidth = 0.001; // Default small width if range is zero
        binCount = 1;
    }

    // Prepare data for ECharts histogram
    // ECharts doesn't have a built-in histogram series type like some libraries.
    // We need to manually bin the data and use a bar chart.
    const bins = [];
    const binLabels = [];
    for (let i = 0; i < binCount; i++) {
        const binStart = minRate + i * binWidth;
        const binEnd = binStart + binWidth;
        bins.push(0);
        // Create label like [binStart, binEnd)
        binLabels.push(`${binStart.toFixed(4)} - ${binEnd.toFixed(4)}`);
    }

    dailyRates.forEach(rate => {
        let binIndex = Math.floor((rate - minRate) / binWidth);
        // Handle edge case where rate equals maxRate
        if (binIndex === binCount) {
            binIndex = binCount - 1;
        }
         if (binIndex >= 0 && binIndex < binCount) { // Ensure index is valid
            bins[binIndex]++;
        }
    });

    const option = {
        tooltip: {
            trigger: 'axis',
            axisPointer: {
                type: 'shadow'
            },
            formatter: function(params) {
                if (!params || params.length === 0) return '';
                const binLabel = params[0].name;
                const count = params[0].value;
                return `范围: ${binLabel}<br/>数量: ${count}`;
            }
        },
        grid: {
            left: '8%',
            right: '5%',
            bottom: '15%',
            top: '15%',
            containLabel: true
        },
        xAxis: {
            type: 'category',
            data: binLabels,
            axisLabel: {
                interval: 'auto', // Show labels automatically, maybe rotate if needed
                rotate: 45,
                fontSize: 11
            },
            axisTick: {
                alignWithLabel: true
            }
        },
        yAxis: {
            type: 'value',
            name: '监测点数量',
            nameTextStyle: { fontSize: 14 },
            axisLabel: { fontSize: 12 }
        },
        series: [
            {
                name: '监测点数量',
                type: 'bar',
                data: bins,
                barWidth: '95%', // Make bars nearly touch
                itemStyle: {
                    color: 'rgba(0, 229, 255, 0.6)', // Use primary color with opacity
                    borderColor: 'rgba(0, 229, 255, 0.8)',
                    borderWidth: 1
                },
                emphasis: {
                     itemStyle: {
                         color: 'rgba(0, 229, 255, 0.9)'
                     }
                 }
            }
        ]
    };

    chart.setOption(option, true);
    charts.daily = chart;

    window.addEventListener('resize', function() {
        if (charts.daily && !charts.daily.isDisposed()) {
            charts.daily.resize();
        }
    });
}

// 初始化主要趋势分析图 (结构)
function initMainTrendChart() {
    const chartContainer = document.getElementById('chart-main-trend');
    chartContainer.style.height = '400px'; // Ensure height

    // Check if chart instance already exists, dispose if so
     if (charts.mainTrend && charts.mainTrend.dispose && !charts.mainTrend.isDisposed()) {
        charts.mainTrend.dispose();
    }

    const chart = echarts.init(chartContainer);
    charts.mainTrend = chart; // Store the instance immediately

    const initialOption = {
        title: {
            left: 'center',
            textStyle: { fontSize: 24, color: '#ffffff' } // Use white
        },
        tooltip: {
            trigger: 'axis',
            // Updated formatter to correctly display values
            formatter: function(params) {
                if (!params || params.length === 0) {
                    return ''; // Return empty if no params
                }
                // Use the first param to get the axis value (Date)
                let result = params[0].axisValue + '<br/>';
                params.forEach(param => {
                    // param.value should contain the y-axis value for this series at this point
                    const seriesName = param.seriesName;
                    const value = param.value;
                    const marker = param.marker; // The colored dot

                    // Check if value is a valid number before formatting
                    if (value !== null && value !== undefined && !isNaN(value)) {
                        result += marker + ' ' + seriesName + ': ' +
                                 parseFloat(value).toFixed(3) + ' mm<br/>'; // Format value
                    } else {
                        // Optionally display something even if data is null/invalid
                        result += marker + ' ' + seriesName + ': 无数据<br/>';
                    }
                });
                return result;
            },
             textStyle: { fontSize: 16, color: '#ffffff' } // Use white for tooltip text
        },
        legend: {
            type: 'scroll',
            top: 5,
            left: 'center',
             width: '70%',
            textStyle: { color: '#cccccc', fontSize: 15 } // Use light grey, consistent with previous edit
        },
        grid: {
            left: '5%',
            right: '5%',
            bottom: '15%',
            top: '60px',
            containLabel: true
        },
        toolbox: {
            feature: {
                saveAsImage: {show: true},
                dataZoom: {show: true},
                restore: {show: true},
                dataView: {show: true}
            },
            right: '20px',
            top: '5px',
            iconStyle: { // Ensure toolbox icons are visible
                borderColor: '#cccccc'
            },
            emphasis: {
                iconStyle: {
                    borderColor: '#00e5ff'
                }
            }
        },
        dataZoom: [
            {
                type: 'slider', show: true, start: 0, end: 100, height: 20, bottom: 10,
                borderColor: 'rgba(0,229,255,0.3)',
                dataBackground: {
                    lineStyle: { color: 'rgba(0,229,255,0.3)' },
                    areaStyle: { color: 'rgba(0,229,255,0.1)' }
                },
                textStyle: { color: '#cccccc', fontSize: 16 }, // Use light grey
                handleStyle: { color: 'rgba(0,229,255,0.9)', borderColor: 'rgba(0,229,255,0.7)' }
            },
            { type: 'inside', start: 0, end: 100 }
        ],
        xAxis: {
            type: 'category', boundaryGap: false, data: [],
            axisLabel: { rotate: 45, color: '#cccccc', fontSize: 18 } // Use light grey
        },
        yAxis: {
            type: 'value', name: '裂缝宽度(mm)', scale: true,
            axisLabel: { color: '#cccccc', fontSize: 18 }, // Use light grey
            nameTextStyle: { color: '#cccccc', fontSize: 18 } // Use light grey
        },
        series: []
    };

    chart.setOption(initialOption); // Set basic structure
    console.log('主趋势图 ECharts 实例已创建');

    // Add resize listener
    window.addEventListener('resize', function() {
        if (charts.mainTrend && !charts.mainTrend.isDisposed()) {
             charts.mainTrend.resize();
        }
    });

    // Initial data load (e.g., first 5 points or empty)
    let initialSelection = [];
    if (monitoringPoints && monitoringPoints.length > 0) {
        initialSelection = monitoringPoints.slice(0, 5).map(p => p.point_id);
        // Pre-select in dropdown
        const selectElement = document.getElementById('main-trend-select');
        if (selectElement) {
             // Clear previous selections first
             Array.from(selectElement.options).forEach(opt => opt.selected = false);
            initialSelection.forEach(id => {
                const option = selectElement.querySelector(`option[value="${id}"]`);
                if (option) option.selected = true;
            });
        }
    }
     console.log('主趋势图初始选择:', initialSelection);
    updateMainTrendChart(initialSelection); // Load initial data
}

// 更新主要趋势分析图数据
function updateMainTrendChart(selectedPointIds) {
    const chart = charts.mainTrend;
    if (!chart || chart.isDisposed()) {
        console.error('主趋势图实例不存在或已销毁');
         // Attempt to re-initialize if destroyed - use with caution
         try {
             initMainTrendChart(); // Re-initialize
             chart = charts.mainTrend; // Get the new instance
             if (!chart || chart.isDisposed()) {
                 console.error('主趋势图重新初始化失败');
                 return;
             }
             console.log('主趋势图实例已重新初始化');
         } catch (e) {
             console.error('重新初始化主趋势图时出错:', e);
             return;
         }
    }

    console.log(`开始更新主趋势图，选择的点: ${selectedPointIds.join(', ')}`);

    if (!crackData || !crackData.series || crackData.series.length === 0 || !crackData.dates || crackData.dates.length === 0) {
        console.warn('无裂缝数据可用于更新主趋势图');
        chart.setOption({
             title: {
                 text: '无裂缝数据或未选择监测点',
                subtext: '请上传数据或选择监测点并点击更新',
                left: 'center',
                top: 'center',
                textStyle: { color: '#999', fontSize: 16 }
            },
            xAxis: { data: [] },
            series: [],
            legend: { data: [] }
        }, { replaceMerge: ['series', 'legend', 'xAxis'] }); // Ensure old data is replaced
        return;
    }

     if (!selectedPointIds || selectedPointIds.length === 0) {
        console.log('未选择监测点，显示提示信息');
         chart.setOption({
            title: {
                text: '请选择监测点并点击更新',
                left: 'center',
                top: 'center',
                textStyle: { color: '#eee', fontSize: 16 }
            },
             xAxis: { data: crackData.dates || [] }, // Keep dates axis if available
            series: [],
            legend: { data: [] }
        }, { replaceMerge: ['series', 'legend'] });
        return;
    }


    // Filter the main crack data based on selected IDs
    const filteredSeries = crackData.series.filter(series =>
        selectedPointIds.includes(series.name)
    );

    if (filteredSeries.length === 0) {
        console.warn('选择的点在数据中未找到:', selectedPointIds);
        chart.setOption({
             title: {
                text: '选择的点无数据显示',
                left: 'center',
                top: 'center',
                textStyle: { color: '#eee', fontSize: 16 }
            },
            xAxis: { data: crackData.dates || [] },
            series: [],
            legend: { data: selectedPointIds } // Show selected names in legend even if no data
        }, { replaceMerge: ['series', 'legend'] });
        return;
    }

    console.log(`筛选后系列数量: ${filteredSeries.length}`);


    // Prepare series data for ECharts
    const colors = [
        '#00e5ff', '#00e676', '#ff3e5f', '#bf5af2', '#ff9e0d',
        '#7986cb', '#4db6ac', '#f06292', '#aed581', '#ffd54f'
    ];

    const echartsSeries = filteredSeries.map((item, index) => {
        // Find corresponding monitoring point info (for trend line, etc.)
        const pointInfo = monitoringPoints.find(p => p.point_id === item.name);

        // Data validation/cleaning (replace null/undefined/NaN with null for ECharts)
        const cleanedData = item.data.map(d => (d === null || d === undefined || isNaN(d)) ? null : parseFloat(d));

        return {
            name: item.name,
            type: 'line',
            data: cleanedData,
            showSymbol: false, // Or true if you want points visible
             connectNulls: false, // Do not connect over null gaps
            lineStyle: {
                width: 2,
                color: colors[index % colors.length] // Use index within filteredSeries for consistent color
            },
            emphasis: { // Optional: Highlight on hover
                 focus: 'series',
                lineStyle: {
                    width: 3
                }
            },
            markPoint: {
                data: [
                    { type: 'max', name: '最大值' },
                    { type: 'min', name: '最小值' }
                ],
                symbolSize: 45, // Slightly larger symbol for label background
                label: {
                    formatter: '{c:.3f}', // Format to 3 decimal places
                    color: '#fff', // White text
                    fontSize: 11, // Slightly larger font
                    offset: [0, -3], // Adjust label position slightly upwards
                    backgroundColor: 'rgba(0, 0, 0, 0.5)', // Semi-transparent black background
                    borderRadius: 3,
                    padding: [3, 5] // Padding around label text
                },
                itemStyle: {
                    // Optional: Change markPoint color if needed, default is series color
                    // color: 'auto'
                }
            },
            // Optional: Add trend line if data exists
             // MarkLine based on slope is removed for simplicity/accuracy concerns
            markLine: undefined
        };
    });

    // Update the chart options
    chart.setOption({
        title: { // Clear any previous 'no data' titles
             text: null,
             subtext: null
         },
        legend: {
            data: filteredSeries.map(item => item.name) // Update legend with selected names
        },
        xAxis: {
            data: crackData.dates || [] // Ensure xAxis data is up-to-date
        },
        yAxis: {
             // Optional: Recalculate min/max based on filtered data if scale=true is not enough
            // min: 'dataMin',
            // max: 'dataMax'
        },
        series: echartsSeries // Update series data
    }, { replaceMerge: ['series', 'legend', 'xAxis'] }); // Use replaceMerge to clear old series/legend/xAxis data


    console.log('主趋势图已使用新数据更新');
}

// 初始化斜率趋势图 (修改为垂直条形图)
function initSlopeChart() {
    const chart = echarts.init(document.getElementById('chart-slope'));

    const names = [];
    const values = [];
    const colors = [];

    monitoringPoints.forEach(point => {
        if (point.trend_slope !== null && typeof point.trend_slope === 'number' && !isNaN(point.trend_slope)) {
            names.push(point.point_id);
            values.push(point.trend_slope);
            const slope = point.trend_slope;
            // Use slightly different color thresholds or palette for visual distinction if desired
            const color = slope > 0.1 ? '#c23531' : // Significant positive slope
                          slope > 0.01 ? '#e98f6f' : // Moderate positive slope
                          slope >= -0.01 ? '#61a0a8' :// Stable / Minor negative slope
                          slope > -0.1 ? '#91c7ae' : // Moderate negative slope
                                           '#2f4554'; // Significant negative slope
            colors.push(color);
        }
    });

    // Keep sorting logic the same (by absolute slope magnitude)
    const indices = Array.from(values.keys());
    indices.sort((a, b) => Math.abs(values[b]) - Math.abs(values[a]));

    const sortedNames = indices.map(i => names[i]);
    const sortedValues = indices.map(i => values[i]);
    const sortedColors = indices.map(i => colors[i]);

    const option = {
        tooltip: {
            trigger: 'axis', // Trigger on axis for vertical bars
            axisPointer: { type: 'shadow' },
            formatter: function(params) {
                 if (!params || params.length === 0) return '';
                 // Find the correct param if multiple series exist (though we only have one)
                 const param = params[0];
                return param.name + '<br/>' + param.seriesName + ': ' + param.value.toFixed(4) + ' mm/天';
            },
            textStyle: { fontSize: 16, color: '#ffffff' },
            confine: true // Keep tooltip within bounds
        },
        grid: {
            left: '12%', // Increased left grid margin significantly
            right: '4%',
            bottom: '20%',
            top: '15%',
            containLabel: true
        },
        // X Axis is now Category (Point Names)
        xAxis: {
            type: 'category',
            data: sortedNames,
            axisLabel: {
                interval: 'auto', // Automatically hide labels
                rotate: 0, // No rotation needed with auto interval
                fontSize: 12, // Smaller font size might help if many labels are shown
                color: '#cccccc'
            },
            axisTick: { alignWithLabel: true }
        },
        // Y Axis is now Value (Slope)
        yAxis: {
            type: 'value',
            name: '趋势斜率(mm/天)',
            nameTextStyle: {
                color: '#cccccc',
                fontSize: 14,
                offset: [-10, 0] // Offset slightly left horizontally
            },
            axisLabel: { color: '#cccccc', formatter: '{value}', fontSize: 14 },
            splitLine: { lineStyle: { color: 'rgba(255, 255, 255, 0.1)' } }
        },
        dataZoom: [ // Add dataZoom for scrolling/zooming x-axis
            {
                type: 'slider',
                xAxisIndex: 0,
                filterMode: 'filter', // Recommended mode
                bottom: 10,
                height: 20,
                start: 0, // Initial view starts from the beginning
                end: sortedNames.length > 50 ? (50 / sortedNames.length) * 100 : 100, // Show first 50 items or all if less
                 textStyle: { color: '#cccccc' } // Use light grey for text
            }
        ],
        series: [
            {
                name: '趋势斜率',
                type: 'bar',
                data: sortedValues,
                label: {
                    show: false, // Hide labels by default to reduce clutter
                    // Keep config if needed later
                    position: 'top',
                    formatter: function(params) { return params.value.toFixed(3); },
                    fontSize: 10, // Smaller font if shown
                    color: '#cccccc',
                    distance: 3
                },
                itemStyle: {
                    color: function(params) {
                        return sortedColors[params.dataIndex];
                    }
                },
                emphasis: {
                     focus: 'series', // Highlight the series on hover
                     itemStyle: {
                         shadowBlur: 10,
                         shadowColor: 'rgba(0, 0, 0, 0.5)'
                     }
                 }
            }
        ]
    };

    chart.setOption(option);
    charts.slope = chart;

    window.addEventListener('resize', function() {
        if (charts.slope && !charts.slope.isDisposed()) {
            charts.slope.resize();
        }
    });
}

// 初始化平均裂缝变化速率图 (修改为柱状图)
function initRateChart() {
    const chart = echarts.init(document.getElementById('chart-rate'));

    const changeTypeData = {};
    monitoringPoints.forEach(point => {
        const type = point.change_type || '未知'; // Handle null/undefined type
        if (point.average_change_rate !== null && typeof point.average_change_rate === 'number' && !isNaN(point.average_change_rate)) {
            if (!changeTypeData[type]) {
                changeTypeData[type] = { count: 0, sumAbsRate: 0 };
            }
            changeTypeData[type].count++;
            changeTypeData[type].sumAbsRate += Math.abs(point.average_change_rate);
        }
    });

    const categories = []; // Store category names (change types)
    const values = []; // Store corresponding average rates
    const colors = {
        '扩展': '#ff9e0d', // Change Expansion to Orange
        '收缩': '#00aaff', // Use the brighter blue for Contraction
        '稳定': '#00e676', // Keep Stable as green
        '未知': '#d48265',
        '数据不足': '#999999'
    };

    // Order the categories for consistent display
    const categoryOrder = ['扩展', '收缩', '稳定', '未知', '数据不足'];

    categoryOrder.forEach(type => {
        if (changeTypeData[type] && changeTypeData[type].count > 0) {
            categories.push(type);
            const avgRate = parseFloat((changeTypeData[type].sumAbsRate / changeTypeData[type].count).toFixed(4));
            values.push({
                value: avgRate,
                itemStyle: { color: colors[type] || '#91c7ae' }
            });
        }
    });


    const option = {
        tooltip: {
            trigger: 'axis', // Trigger tooltip on axis
            axisPointer: { type: 'shadow' },
            formatter: function(params) {
                if (!params || params.length === 0) return '';
                const param = params[0];
                return `${param.name}<br/>${param.seriesName}: ${param.value.toFixed(4)} mm/天`;
            },
            textStyle: { fontSize: 16, color: '#ffffff' },
            confine: true // Keep tooltip within bounds
        },
        grid: { // Adjust grid for bar chart
            left: '12%', // Increased left grid margin significantly
            right: '4%',
            bottom: '10%',
            top: '15%',
            containLabel: true
        },
        xAxis: {
            type: 'category', // X-axis is category (change type)
            data: categories,
            axisLabel: {
                color: '#cccccc', // Use light grey
                fontSize: 16 // Increased from 12
            },
             axisTick: {
                alignWithLabel: true
            }
        },
        yAxis: {
            type: 'value', // Y-axis is value (average rate)
            name: '平均速率绝对值 (mm/天)',
            nameTextStyle: {
                color: '#cccccc',
                fontSize: 14,
                offset: [-10, 0] // Offset slightly left horizontally
            },
            axisLabel: {
                color: '#cccccc',
                formatter: '{value}',
                fontSize: 14
            },
             splitLine: { lineStyle: { color: 'rgba(255, 255, 255, 0.1)' } }
        },
        legend: { // Hide legend as categories are on axis
            show: false
        },
        series: [
            {
                name: '平均速率(绝对值)',
                type: 'bar',
                data: values, // Use the processed values array
                barWidth: '60%', // Adjust bar width if desired
                label: { // Show labels on top of bars
                    show: true,
                    position: 'top',
                    formatter: '{c}', // Display the value (c)
                    fontSize: 14, // Increased from 10
                    color: '#cccccc',
                    distance: 5
                },
                 emphasis: { // Add emphasis style
                     focus: 'series',
                     itemStyle: {
                         shadowBlur: 10,
                         shadowColor: 'rgba(0, 0, 0, 0.5)'
                     }
                 }
            }
        ]
    };

    chart.setOption(option);
    charts.rate = chart;

    window.addEventListener('resize', function() {
        if (charts.rate && !charts.rate.isDisposed()) {
            charts.rate.resize();
        }
    });
}

// 初始化相关性图
function initCorrelationChart() {
    const chart = echarts.init(document.getElementById('chart-correlation'));

    // Limit to first 15 points for readability if too many
    const pointsToShow = monitoringPoints.length > 15 ? monitoringPoints.slice(0, 15) : monitoringPoints;
    const pointIds = pointsToShow.map(p => p.point_id);
    const n = pointIds.length;

    // Placeholder for correlation data - ideally fetched from backend
    let correlationData = [];
    let maxValue = 1;
    let minValue = -1;

    if (n > 0) {
         // Simplified model: Assume points have some random correlation for demo
         // Replace this with actual fetched data when available
        correlationData = [];
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                let correlation = 0;
                if (i === j) {
                    correlation = 1;
                } else {
                    // Generate somewhat plausible random correlations
                    // This is purely for visual demonstration
                    correlation = Math.random() * 1.6 - 0.8; // Range approx -0.8 to 0.8
                    correlation = parseFloat(correlation.toFixed(2));
                }
                correlationData.push([i, j, correlation]);
            }
        }
         // Calculate actual min/max from generated data for visualMap
         const values = correlationData.map(item => item[2]);
         minValue = Math.min(...values);
         maxValue = Math.max(...values);
         // Ensure min/max are at least -1/1 if data range is smaller
         minValue = Math.min(minValue, -1);
         maxValue = Math.max(maxValue, 1);

    } else {
        console.warn('无监测点数据，无法生成相关性图');
    }


    const option = {
        tooltip: {
            position: 'top',
            formatter: function (params) {
                if (!pointIds[params.value[0]] || !pointIds[params.value[1]]) return '';
                return `${pointIds[params.value[0]]} 与 ${pointIds[params.value[1]]}<br/>相关系数: ${params.value[2]}`;
            },
            textStyle: { fontSize: 16, color: '#ffffff' } // Use white
        },
        grid: {
            left: '10%', // Adjust grid for labels
            right: '5%',
            bottom: '15%', // Adjust for visualMap
            top: '5%',
            containLabel: true
        },
        xAxis: {
            type: 'category',
            data: pointIds,
            axisLabel: { interval: 0, rotate: 45, fontSize: 12, color: '#cccccc' }, // Adjust font size
            splitArea: { show: true }
        },
        yAxis: {
            type: 'category',
            data: pointIds,
            axisLabel: { interval: 0, fontSize: 12, color: '#cccccc' }, // Adjust font size
            splitArea: { show: true }
        },
        visualMap: {
            min: minValue,
            max: maxValue,
            calculable: true,
            orient: 'horizontal',
            left: 'center',
            bottom: '2%',
            inRange: {
                // Blue -> White -> Red gradient
                color: ['#2f4554', '#61a0a8', '#ffffff', '#e98f6f', '#c23531']
            },
             textStyle: { color: '#cccccc', fontSize: 16 } // Use light grey
        },
        series: [{
            name: '相关系数',
            type: 'heatmap',
            data: correlationData,
            label: {
                show: n <= 10, // Show labels only if few points
                 formatter: '{@[2]}', // Show correlation value
                 color: '#ffffff', // Use white for heatmap labels
                 textShadowColor: 'rgba(0, 0, 0, 0.7)',
                 textShadowBlur: 2,
                 fontSize: 12 // Increased font size for heatmap labels
            },
            emphasis: {
                itemStyle: {
                    shadowBlur: 10,
                    shadowColor: 'rgba(0, 0, 0, 0.5)'
                }
            }
        }]
    };

    // Display message if no data
    if (n === 0) {
        option.title = {
            text: '无数据可显示相关性',
            left: 'center', top: 'center',
            textStyle: { color: '#999', fontSize: 16 }
        };
        option.series = []; // Clear series if no data
        option.visualMap = null; // Hide visualMap
    }

    chart.setOption(option);
    charts.correlation = chart;

    window.addEventListener('resize', function() {
        if (charts.correlation && !charts.correlation.isDisposed()) {
            charts.correlation.resize();
        }
    });
}

// 更新数据表格
function updateDataTable() {
    console.log('更新数据表格');
    const tableContainer = document.querySelector('.data-table').closest('.chart-body'); // Get parent container for better structure
    const table = tableContainer.querySelector('.data-table');
    const tbody = table.querySelector('tbody');

    // Ensure table container exists
    if (!tableContainer) {
        console.error('无法找到数据表格容器 .chart-body');
        return;
    }
    // Ensure table and tbody exist
    if (!table || !tbody) {
        console.error('无法找到数据表格 <table> 或 <tbody>');
        return;
    }

    // --- Apply Styles (Consolidated) ---
    tableContainer.style.maxHeight = '400px';
    tableContainer.style.overflowY = 'auto';
    tableContainer.style.position = 'relative';
    tableContainer.style.border = '1px solid rgba(0, 229, 255, 0.3)';
    tableContainer.style.borderRadius = '4px';
    tableContainer.style.padding = '0'; // Remove padding from container itself
    tableContainer.style.margin = '0'; // Use parent margins
    tableContainer.style.backgroundColor = 'rgba(12, 20, 38, 0.6)';
    tableContainer.style.width = '100%';

    // --- Inject CSS for table and scrollbar (if not already present) ---
    if (!document.getElementById('data-table-styles')) {
        const style = document.createElement('style');
        style.id = 'data-table-styles'; // Add ID to prevent duplicates
        style.textContent = `
            .chart-body { /* Apply scrollbar styles to the container */
                scrollbar-width: thin;
                scrollbar-color: rgba(0, 229, 255, 0.5) rgba(0, 0, 0, 0.1);
            }
            .chart-body::-webkit-scrollbar {
                width: 8px;
            }
            .chart-body::-webkit-scrollbar-track {
                background: rgba(0, 0, 0, 0.1);
                border-radius: 4px;
            }
            .chart-body::-webkit-scrollbar-thumb {
                background-color: rgba(0, 229, 255, 0.5);
                border-radius: 4px;
            }
            .data-table {
                width: 100%;
                border-collapse: collapse;
                table-layout: fixed; /* Use fixed layout */
                 margin: 0; /* Remove table margin */
                 padding: 0; /* Remove table padding */
            }
            .data-table th {
                background-color: rgba(0, 100, 120, 0.5); /* Darker, less intense cyan */
                color: white;
                position: sticky;
                top: 0;
                z-index: 10;
                padding: 10px 8px; /* Slightly more padding */
                text-align: center;
                font-weight: 600; /* Slightly bolder */
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                 border: 1px solid rgba(0, 229, 255, 0.2); /* Lighter border for header */
            }
            .data-table th, .data-table td {
                padding: 8px 6px; /* Adjust padding */
                border: 1px solid rgba(0, 229, 255, 0.15); /* Slightly lighter border */
                text-align: center;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                font-size: 13px; /* Slightly smaller font */
            }
            .data-table td.numeric {
                text-align: right;
                font-family: 'Consolas', 'Courier New', monospace;
            }
            .data-table tbody tr:nth-child(even) {
                 background-color: rgba(0, 229, 255, 0.03); /* Subtle striping */
            }
            .data-table tbody tr:hover {
                background-color: rgba(0, 229, 255, 0.1);
            }
            /* Allow content to wrap/show on hover */
            .data-table tbody tr:hover td {
                white-space: normal;
                overflow: visible;
                 position: relative; /* Needed for potential tooltips or popovers */
                 z-index: 1; /* Ensure hovered cell content is above others */
            }
            .data-table tbody td {
                color: rgba(255, 255, 255, 0.85);
            }
            .table-title-container { /* Container for title and filters */
                 padding: 10px 15px;
                 background-color: rgba(12, 20, 38, 0.7);
                 border-bottom: 1px solid rgba(0, 229, 255, 0.2);
                 margin-bottom: 0; /* Remove margin below title/filters */
            }
             .table-title {
                 margin-bottom: 10px;
                 text-align: center;
                 padding: 0;
                 font-weight: bold;
                 color: #eee !important; /* Use !important carefully */
                 font-size: 15px !important;
            }
            .table-title span {
                 font-size: 12px;
                 color: rgba(255, 255, 255, 0.7);
                 display: block;
                 font-weight: normal;
                 margin-top: 3px;
            }
             .filter-controls {
                 margin-bottom: 0; /* Remove bottom margin */
                 padding: 5px 0 0 0; /* Add padding top */
                 /* background-color: rgba(0, 229, 255, 0.05); Removed bg color */
                 /* border-radius: 4px; */
                 display: flex;
                 flex-wrap: wrap;
                 gap: 10px;
                 justify-content: center;
                 align-items: center;
            }
            .filter-control {
                display: flex;
                align-items: center;
                gap: 5px;
            }
            .filter-control label {
                color: rgba(255, 255, 255, 0.8);
                font-size: 12px;
            }
            .filter-control select, .filter-control input {
                background-color: rgba(12, 20, 38, 0.9);
                border: 1px solid rgba(0, 229, 255, 0.4);
                color: white;
                padding: 4px 8px; /* Slightly larger padding */
                border-radius: 3px;
                 font-size: 12px;
            }
            .filter-control button.refresh-btn {
                 background-color: rgba(0, 150, 180, 0.4);
                 border: 1px solid rgba(0, 229, 255, 0.5);
                 color: white;
                 padding: 4px 10px;
                 border-radius: 3px;
                 cursor: pointer;
                 font-size: 12px;
                 transition: background-color 0.2s ease;
            }
             .filter-control button.refresh-btn:hover {
                 background-color: rgba(0, 180, 210, 0.5);
             }
        `;
        document.head.appendChild(style);
    }

    // --- Create Title and Filter Controls (if not already present) ---
     let titleFilterContainer = tableContainer.previousElementSibling;
    if (!titleFilterContainer || !titleFilterContainer.classList.contains('table-title-container')) {
         titleFilterContainer = document.createElement('div');
         titleFilterContainer.className = 'table-title-container';

        // Table Title
         const tableTitle = document.createElement('div');
        tableTitle.className = 'table-title';
        tableTitle.innerHTML = '裂缝监测数据表<span>下表显示了裂缝监测的详细数据，可滚动查看</span>';
        titleFilterContainer.appendChild(tableTitle);

         // Filter Controls Container
         const filterControls = document.createElement('div');
         filterControls.className = 'filter-controls';

        // Point Filter
         const pointFilter = document.createElement('div');
         pointFilter.className = 'filter-control';
        pointFilter.innerHTML = `
            <label for="point-filter">监测点:</label>
            <select id="point-filter">
                <option value="all">全部</option>
                ${monitoringPoints.map(point =>
                    `<option value="${point.point_id}">${point.point_id}</option>`
                ).join('')}
            </select>
        `;

        // Date Range Filter
        const dateRangeFilter = document.createElement('div');
        dateRangeFilter.className = 'filter-control';
        dateRangeFilter.innerHTML = `
            <label for="date-range">数据量:</label>
            <select id="date-range">
                <option value="10">最近10条</option>
                <option value="30">最近30条</option>
                <option value="50">最近50条</option>
                <option value="100" selected>最近100条</option> /* Default to 100 */
                <option value="all">全部数据</option>
            </select>
        `;

        // Refresh Button
        const refreshButton = document.createElement('button');
         refreshButton.className = 'refresh-btn'; // Add class for styling
         refreshButton.innerHTML = '<i class="fas fa-sync-alt"></i> 刷新'; // Use icon
        refreshButton.addEventListener('click', updateTableData);

         // Assemble Filters
         filterControls.appendChild(pointFilter);
         filterControls.appendChild(dateRangeFilter);
         filterControls.appendChild(refreshButton);
        titleFilterContainer.appendChild(filterControls);

        // Insert before the table's chart-body container
         tableContainer.parentNode.insertBefore(titleFilterContainer, tableContainer);

         // Add listeners to filters to auto-refresh (optional, but good UX)
         document.getElementById('point-filter').addEventListener('change', updateTableData);
         document.getElementById('date-range').addEventListener('change', updateTableData);
    }

    // --- Update Table Header ---
    const thead = table.querySelector('thead');
    if (thead) {
        thead.innerHTML = `
            <tr>
                <th style="width: 25%">日期</th>
                <th style="width: 20%">监测点</th>
                <th style="width: 25%">裂缝宽度(mm)</th>
                <th style="width: 30%">变化类型</th> <!-- Adjusted widths -->
            </tr>
        `;
    }

    // --- Clear Scroll Hint (if exists) ---
    const existingScrollHint = tableContainer.querySelector('.scroll-hint');
    if (existingScrollHint) existingScrollHint.remove();

    // --- Initial Data Populate ---
    updateTableData(); // Call the function to populate/re-populate data

    // --- Add Scroll Hint (if content overflows) ---
    // Check for overflow *after* populating data (use a small delay)
     setTimeout(() => {
        if (tableContainer.scrollHeight > tableContainer.clientHeight) {
            const scrollHint = document.createElement('div');
            scrollHint.className = 'scroll-hint'; // Add class for potential styling
            scrollHint.innerHTML = '<i class="fas fa-chevron-down"></i>';
            // Apply styles as defined before
            scrollHint.style.textAlign = 'center';
            scrollHint.style.color = 'rgba(0, 229, 255, 0.6)';
            scrollHint.style.padding = '5px 0';
            scrollHint.style.fontSize = '14px';
            scrollHint.style.position = 'sticky';
            scrollHint.style.bottom = '0';
            scrollHint.style.background = 'rgba(12, 20, 38, 0.8)';
            scrollHint.style.width = '100%';
            scrollHint.style.zIndex = '5';
            tableContainer.appendChild(scrollHint);
        }
    }, 100); // Delay to allow rendering


    // --- Nested Function to Update Table Data ---
    function updateTableData() {
        // Get filters
        const selectedPoint = document.getElementById('point-filter').value;
        const dateRange = document.getElementById('date-range').value;

        // Clear existing rows
        tbody.innerHTML = '';

        // Check if data is available
        if (!crackData || !crackData.series || crackData.series.length === 0 || !crackData.dates || crackData.dates.length === 0) {
            tbody.innerHTML = '<tr><td colspan="4" style="text-align:center; color: #888;">暂无裂缝数据</td></tr>'; // Colspan = 4
            return;
        }

        // Process and filter data
        const tableData = [];
        let totalPoints = crackData.dates.length;
        let startIndex = 0;
        if (dateRange !== 'all') {
            startIndex = Math.max(0, totalPoints - parseInt(dateRange));
        }

        for (let i = startIndex; i < totalPoints; i++) {
            const currentDate = crackData.dates[i];
            for (let j = 0; j < crackData.series.length; j++) {
                const series = crackData.series[j];

                // Filter by point
                if (selectedPoint !== 'all' && series.name !== selectedPoint) {
                    continue;
                }

                // Check if data exists for this point and date
                const value = series.data[i];
                if (value !== null && value !== undefined && !isNaN(value)) {
                    const pointInfo = monitoringPoints.find(p => p.point_id === series.name);
                    if (!pointInfo) continue; // Skip if point metadata not found

                    // const location = pointInfo.location || "未知"; // Removed location
                    const changeType = pointInfo.change_type || "未知";

                    // Format value
                    let displayValue;
                    const absValue = Math.abs(value);
                    if (absValue > 0 && absValue < 0.0001) {
                        displayValue = value.toExponential(2);
                    } else if (absValue > 10000) {
                        displayValue = value.toExponential(2);
                    } else {
                        displayValue = parseFloat(value).toFixed(3);
                    }

                    tableData.push({
                        date: currentDate,
                        point: series.name,
                        value: value,
                        displayValue: displayValue,
                        // location: location, // Removed location
                        changeType: changeType
                    });
                }
            }
        }

        // Display data or 'no match' message
        if (tableData.length === 0) {
            tbody.innerHTML = '<tr><td colspan="4" style="text-align:center; color: #888;">没有匹配筛选条件的数据</td></tr>'; // Colspan = 4
        } else {
            // Sort by date (most recent first)
            tableData.sort((a, b) => new Date(b.date) - new Date(a.date));

            // Populate table rows
             const fragment = document.createDocumentFragment(); // Use fragment for performance
            tableData.forEach(row => {
                const tr = document.createElement('tr');
                let valueCellClass = 'numeric';

                // Apply subtle background based on change type
                if (row.changeType === '扩展') {
                    tr.style.setProperty('--row-bg-color', 'rgba(194, 53, 49, 0.05)');
                } else if (row.changeType === '收缩') {
                    tr.style.setProperty('--row-bg-color', 'rgba(47, 69, 84, 0.08)');
                } else if (row.changeType === '稳定') {
                    tr.style.setProperty('--row-bg-color', 'rgba(97, 160, 168, 0.05)');
                }
                 // Use CSS variable for background
                 tr.style.backgroundColor = 'var(--row-bg-color, transparent)';

                tr.innerHTML = `
                    <td>${row.date}</td>
                    <td>${row.point}</td>
                    <td class="${valueCellClass}" title="${row.value}">${row.displayValue}</td>
                    <td>${row.changeType}</td>
                `; // Removed location cell
                fragment.appendChild(tr);
            });
             tbody.appendChild(fragment); // Append fragment once
        }
         // Re-check for scroll hint after updating data
         setTimeout(() => {
             const currentHint = tableContainer.querySelector('.scroll-hint');
             if (tableContainer.scrollHeight > tableContainer.clientHeight) {
                 if (!currentHint) { // Add hint if needed and not present
                     const scrollHint = document.createElement('div');
                     scrollHint.className = 'scroll-hint';
                     scrollHint.innerHTML = '<i class="fas fa-chevron-down"></i>';
                     // Apply styles as defined before
                     scrollHint.style.textAlign = 'center';
                     scrollHint.style.color = 'rgba(0, 229, 255, 0.6)';
                     scrollHint.style.padding = '5px 0';
                     scrollHint.style.fontSize = '14px';
                     scrollHint.style.position = 'sticky';
                     scrollHint.style.bottom = '0';
                     scrollHint.style.background = 'rgba(12, 20, 38, 0.8)';
                     scrollHint.style.width = '100%';
                     scrollHint.style.zIndex = '5';
                     tableContainer.appendChild(scrollHint);
                }
             } else {
                 if (currentHint) currentHint.remove(); // Remove hint if not needed
             }
         }, 50);
    } // End of updateTableData function

}

// 显示上传模态框
function showUploadModal() {
    document.getElementById('upload-modal').style.display = 'block';
    document.getElementById('file-info').style.display = 'none';
    document.getElementById('upload-progress').style.display = 'none';
    document.getElementById('processing-status').style.display = 'none';
    document.getElementById('upload-message').textContent = '';
}

// 处理文件选择
function handleFileSelect(event) {
    const file = event.target.files[0];
    if (file) {
        displayFileInfo(file);
    }
}

// 处理文件拖放
function handleDrop(event) {
    event.preventDefault();
    event.stopPropagation();
    unhighlight(); // Remove highlight from drop area

    const dt = event.dataTransfer;
    const file = dt.files[0];

    if (file) {
        document.getElementById('file-input').files = dt.files;
        displayFileInfo(file);
    }
}

// Helper function to display selected file info
function displayFileInfo(file) {
    if (!file) return;
    document.getElementById('file-name').textContent = file.name;
    document.getElementById('file-info').style.display = 'block';
    document.querySelector('#drop-area .drop-text').style.display = 'none'; // Hide drop text
}

// 上传文件
function uploadFile() {
    console.log('===== uploadFile 函数被调用 =====');

    const fileInput = document.getElementById('file-input');
    if (!fileInput.files || fileInput.files.length === 0) {
        console.log('错误: 未选择文件');
        showNotification('请选择文件', 'error');
        return;
    }

    const file = fileInput.files[0];
    console.log(`选择的文件: ${file.name} (${file.size} 字节)`);

    if (!file.name.endsWith('.xlsx') && !file.name.endsWith('.xls')) {
        console.log('错误: 文件类型不支持');
        showNotification('只支持Excel文件(.xlsx, .xls)', 'error');
        return;
    }

    console.log('文件验证通过，准备上传...');

    // 显示上传进度
    document.getElementById('file-info').style.display = 'none';
    document.getElementById('upload-progress').style.display = 'block';
    const progressBar = document.getElementById('progress-bar-fill');
    const progressText = document.getElementById('progress-text');

    // 创建FormData对象
    const formData = new FormData();
    formData.append('file', file);
    console.log('FormData 对象已创建并添加文件');

    // 模拟上传进度
    let progress = 0;
    console.log('开始模拟上传进度');
    const progressInterval = setInterval(() => {
        progress += 5;
        if (progress > 90) {
            clearInterval(progressInterval);
            console.log('进度模拟达到 90%，停止模拟');
        }
        progressBar.style.width = progress + '%';
        progressText.textContent = `上传中... ${progress}%`;
    }, 200);

    // 发送上传请求
    console.log('开始发送请求到: /api/crack/upload');
    fetch('/api/crack/upload', {
        method: 'POST',
        body: formData
    })
    .then(response => {
        console.log(`收到服务器响应，状态码: ${response.status}`);
        return response.json();
    })
    .then(data => {
        console.log('解析响应数据:', data);
        clearInterval(progressInterval);
        progressBar.style.width = '100%';
        progressText.textContent = '上传完成 100%';

        // 显示处理状态
        console.log('准备显示处理状态');
        setTimeout(() => {
            document.getElementById('upload-progress').style.display = 'none';
            document.getElementById('processing-status').style.display = 'block';
            document.getElementById('status-text').textContent = '正在处理数据...';
            console.log('显示"正在处理数据..."状态');

            // 模拟数据处理时间
            setTimeout(() => {
                console.log('数据处理完成');
                document.getElementById('processing-status').style.display = 'none';
                document.getElementById('upload-message').textContent = data.message || '操作完成';

                if (data.status === 'success') {
                    console.log('操作成功，准备刷新页面');
                    showNotification('文件上传成功，正在刷新数据...', 'success');

                    // 重新获取数据并更新图表
                    setTimeout(() => {
                        console.log('刷新页面...');
                        location.reload();
                    }, 2000);
                } else {
                    console.log('操作失败:', data.message);
                    showNotification(data.message || '操作失败', 'error');
                }
            }, 2000);
        }, 500);
    })
    .catch(error => {
        console.error('请求发生错误:', error);
        clearInterval(progressInterval);
        document.getElementById('upload-progress').style.display = 'none';
        document.getElementById('upload-message').textContent = '上传失败: ' + error.message;
        showNotification('上传失败: ' + error.message, 'error');
    });
}

// 显示通知
function showNotification(message, type = 'info') {
    const notification = document.getElementById('notification');
    const notificationText = document.getElementById('notification-text');

    notificationText.textContent = message;
    notification.className = 'notification ' + type;
    notification.style.display = 'block';

    setTimeout(() => {
        notification.style.opacity = '1';
    }, 10);

    setTimeout(() => {
        notification.style.opacity = '0';
        setTimeout(() => {
            notification.style.display = 'none';
        }, 300);
    }, 3000);
}

// 添加图表放大功能
function setupChartZoom(charts) {
    console.log('设置图表放大功能');

    // 创建模态框（如果不存在）
    let zoomModal = document.getElementById('chart-zoom-modal');
    if (!zoomModal) {
        zoomModal = document.createElement('div');
        zoomModal.id = 'chart-zoom-modal';
        zoomModal.className = 'chart-zoom-modal';
        zoomModal.style.display = 'none';
        zoomModal.style.position = 'fixed';
        zoomModal.style.zIndex = '1000';
        zoomModal.style.left = '0';
        zoomModal.style.top = '0';
        zoomModal.style.width = '100%';
        zoomModal.style.height = '100%';
        zoomModal.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
        zoomModal.style.display = 'none';
        zoomModal.style.justifyContent = 'center';
        zoomModal.style.alignItems = 'center';

        // 添加关闭按钮
        const closeBtn = document.createElement('span');
        closeBtn.innerHTML = '&times;';
        closeBtn.style.position = 'absolute';
        closeBtn.style.top = '20px';
        closeBtn.style.right = '30px';
        closeBtn.style.color = 'white';
        closeBtn.style.fontSize = '35px';
        closeBtn.style.fontWeight = 'bold';
        closeBtn.style.cursor = 'pointer';
        closeBtn.style.zIndex = '1001';
        closeBtn.onclick = function() {
            closeZoomModal();
        };

        // 添加内容容器
        const contentDiv = document.createElement('div');
        contentDiv.id = 'chart-zoom-content';
        contentDiv.style.width = '80%';
        contentDiv.style.height = '80%';
        contentDiv.style.backgroundColor = 'rgba(12, 20, 38, 0.95)';
        contentDiv.style.borderRadius = '8px';
        contentDiv.style.padding = '20px';
        contentDiv.style.boxShadow = '0 0 15px rgba(0, 229, 255, 0.5)';
        contentDiv.style.position = 'relative';
        contentDiv.style.display = 'flex';
        contentDiv.style.flexDirection = 'column';

        // 添加标题
        const titleDiv = document.createElement('div');
        titleDiv.id = 'chart-zoom-title';
        titleDiv.style.color = 'white';
        titleDiv.style.fontSize = '20px';
        titleDiv.style.fontWeight = 'bold';
        titleDiv.style.marginBottom = '15px';
        titleDiv.style.borderBottom = '1px solid rgba(0, 229, 255, 0.3)';
        titleDiv.style.paddingBottom = '10px';

        // 添加图表容器
        const chartDiv = document.createElement('div');
        chartDiv.id = 'chart-zoom-chart';
        chartDiv.style.flex = '1';
        chartDiv.style.width = '100%';

        // 组装DOM
        contentDiv.appendChild(titleDiv);
        contentDiv.appendChild(chartDiv);
        zoomModal.appendChild(closeBtn);
        zoomModal.appendChild(contentDiv);
        document.body.appendChild(zoomModal);
    }

    // 为所有图表容器添加点击事件
    const chartContainers = document.querySelectorAll('.chart');
    chartContainers.forEach(container => {
        container.style.cursor = 'pointer';

        // 添加小图标提示点击可放大
        const zoomIcon = document.createElement('div');
        zoomIcon.className = 'chart-zoom-icon';
        zoomIcon.innerHTML = '<i class="fas fa-search-plus"></i>';
        zoomIcon.style.position = 'absolute';
        zoomIcon.style.top = '10px';
        zoomIcon.style.right = '10px';
        zoomIcon.style.color = 'rgba(255, 255, 255, 0.7)';
        zoomIcon.style.fontSize = '14px';
        zoomIcon.style.zIndex = '10';
        zoomIcon.style.background = 'rgba(0, 0, 0, 0.3)';
        zoomIcon.style.padding = '5px';
        zoomIcon.style.borderRadius = '4px';

        // 确保容器有相对定位，才能正确放置图标
        if (getComputedStyle(container).position === 'static') {
            container.style.position = 'relative';
        }

        container.appendChild(zoomIcon);

        // 点击事件
        container.addEventListener('click', function() {
            const chartId = this.id;
            const chartTitle = this.closest('.chart-container').querySelector('.chart-title').textContent;
            openZoomModal(chartId, chartTitle);
        });
    });

    // 打开放大模态框
    function openZoomModal(chartId, chartTitle) {
        console.log('打开放大模态框:', chartId);
        const zoomModal = document.getElementById('chart-zoom-modal'); // Use correct modal ID
        if (!zoomModal) {
            console.error("Zoom modal #chart-zoom-modal not found!");
            return;
        }
        const zoomChartTitle = document.getElementById('chart-zoom-title');
        const modalChartElement = document.getElementById('chart-zoom-chart'); // Use correct chart element ID
        const zoomContentDiv = document.getElementById('chart-zoom-content'); // Container for title and chart

        if (!zoomChartTitle || !modalChartElement || !zoomContentDiv) {
            console.error("Zoom modal elements (#chart-zoom-title, #chart-zoom-chart, #chart-zoom-content) not found!");
            return;
        }

        // --- Start: Add Description Logic ---
        // Find or create the description paragraph inside the content div
        let zoomChartDescription = document.getElementById('chart-zoom-description');
        if (!zoomChartDescription) {
            zoomChartDescription = document.createElement('p');
            zoomChartDescription.id = 'chart-zoom-description'; // Use consistent ID for styling
            // Insert description after the title div within the content div
            zoomContentDiv.insertBefore(zoomChartDescription, modalChartElement); // Insert before the chart element
            // Apply common styles via CSS using the ID #zoom-chart-description (added previously)
        }
        zoomChartDescription.textContent = ''; // Clear previous description

        // Find original description text from the main page
        const originalChartElement = document.getElementById(chartId);
        if (!originalChartElement) {
            console.error(`Original chart element with ID ${chartId} not found!`);
            return;
        }
        const chartContainer = originalChartElement.closest('.chart-container');
        let descriptionText = '';
        if (chartContainer) {
            const descriptionElement = chartContainer.querySelector('.chart-header .chart-description');
            if (descriptionElement) {
                descriptionText = descriptionElement.textContent;
            }
        }

        // Set title and description
        zoomChartTitle.textContent = chartTitle;
        zoomChartDescription.textContent = descriptionText;
        // --- End: Add Description Logic ---

        // Show modal
        zoomModal.style.display = 'flex'; // Use flex as per original style

        // Get original chart instance (using global charts object as likely used in cracks_charts.js)
        let sourceChart = null;
        for (const [key, chart] of Object.entries(charts)) {
            if (chart && chart.getDom().id === chartId) {
                sourceChart = chart;
                break;
            }
        }

        if (!sourceChart) {
            console.error('找不到原图表实例:', chartId);
            modalChartElement.innerHTML = '<div class="empty-chart"><p>无法加载图表数据 (源图表实例未找到)</p></div>';
            return;
        }

        // Initialize zoomed chart (ensure container is ready)
         modalChartElement.innerHTML = ''; // Clear previous content
         modalChartElement.style.width = '100%'; // Ensure dimensions
         modalChartElement.style.height = '100%'; // Ensure dimensions

        setTimeout(() => {
            try {
                const zoomedChartInstance = echarts.init(modalChartElement);
                const option = sourceChart.getOption();
                // Optionally adjust options for zoom view
                if (option.title) option.title.show = false; // Hide original title
                // Apply options
                zoomedChartInstance.setOption(option);
                zoomedChartInstance.resize(); // Ensure size adaptation

                // Store instance for cleanup
                zoomModal._zoomedChartInstance = zoomedChartInstance;

                // Add resize listener
                 const resizeHandler = () => {
                     if (zoomModal.style.display !== 'none' && zoomModal._zoomedChartInstance) {
                        zoomModal._zoomedChartInstance.resize();
                     }
                 };
                 window.addEventListener('resize', resizeHandler);
                 zoomModal._resizeHandler = resizeHandler; // Store handler

            } catch (e) {
                console.error("Error initializing or setting options for zoomed chart:", e);
                modalChartElement.innerHTML = '<div class="empty-chart"><p>加载图表时出错</p></div>';
            }
        }, 50); // Shorter delay might suffice
    }

    // Close zoom modal (Restored original structure + description clear)
    function closeZoomModal() {
        const zoomModal = document.getElementById('chart-zoom-modal'); // Use correct modal ID
        if (!zoomModal) return;

        zoomModal.style.display = 'none'; // Hide the modal

        // --- Start: Clear Description Logic ---
        // Clear the description text
        const zoomChartDescription = document.getElementById('chart-zoom-description');
        if (zoomChartDescription) {
            zoomChartDescription.textContent = '';
        }
        // --- End: Clear Description Logic ---

        // Remove resize listener if stored
        if (zoomModal._resizeHandler) {
             window.removeEventListener('resize', zoomModal._resizeHandler);
             zoomModal._resizeHandler = null;
        }

        // Dispose of the chart instance in the modal
        if (zoomModal._zoomedChartInstance) {
            try {
                 zoomModal._zoomedChartInstance.dispose();
            } catch (e) {
                 console.error("Error disposing zoomed chart instance:", e);
            }
            zoomModal._zoomedChartInstance = null;
        }

        // Clear the chart container itself
        const modalChartElement = document.getElementById('chart-zoom-chart');
        if (modalChartElement) {
            modalChartElement.innerHTML = '';
        }
    }

    // 添加样式到文档
    const style = document.createElement('style');
    style.textContent = `
        .chart-container .chart:hover .chart-zoom-icon {
            color: rgba(0, 229, 255, 0.9);
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .chart-zoom-modal.active .chart-zoom-icon {
            animation: pulse 1.5s infinite;
        }
    `;
    document.head.appendChild(style);
}