<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unity Render Streaming 点位选择测试</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
        }
        .container {
            display: flex;
            height: calc(100vh - 50px); /* Adjusted for nav bar */
        }
        .unity-container { /* Renamed to video-container maybe? */
            flex: 2;
            position: relative;
            background-color: #000; /* Black background for video */
        }
        /* Style for the video element */
        #render-stream-video {
            width: 100%;
            height: 100%;
            display: block; /* Remove extra space below video */
        }
        /* Removed loading bar styles as Render Streaming has its own indicators */
        .control-panel {
            flex: 1;
            padding: 20px;
            background-color: #fff;
            box-shadow: -2px 0 10px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
            min-width: 300px; /* Ensure control panel has some width */
        }
        h1, h2 {
            color: #333;
        }
        .section {
            margin-bottom: 30px;
            padding: 15px;
            border-radius: 8px;
            background-color: #f9f9f9;
        }
        button {
            margin: 5px;
            padding: 10px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        button:hover:not(:disabled) {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        select {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        .log-container {
            height: 150px;
            overflow-y: auto;
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #ddd;
            font-family: monospace;
        }
        .log-entry {
            margin: 5px 0;
            padding: 3px;
            border-bottom: 1px solid #eee;
            word-wrap: break-word;
        }
        /* 导航栏样式 */
        .nav-bar {
            background-color: #2c3e50;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 50px; /* Fixed height */
            box-sizing: border-box;
        }
        .nav-title {
            color: white;
            font-size: 18px;
            font-weight: bold;
        }
        .back-link {
            color: white;
            text-decoration: none;
            display: flex;
            align-items: center;
        }
        .back-link:hover {
            text-decoration: underline;
        }
        /* 监测点网格布局 */
        .points-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(50px, 1fr)); /* Responsive grid */
            gap: 10px;
            margin-top: 15px;
        }
        .point-button {
            padding: 8px;
            text-align: center;
            background-color: #2c3e50;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .point-button:hover {
            background-color: #3498db;
            transform: translateY(-2px);
        }
        .point-button.active {
            background-color: #4CAF50;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
        }
        /* Removed camera settings styles */
        /* 统计信息 */
        .stats {
            margin-top: 15px;
            background-color: #f0f8ff;
            padding: 10px;
            border-radius: 4px;
            border-left: 4px solid #3498db;
        }
        .stats-title {
            font-weight: bold;
            margin-bottom: 5px;
            color: #2c3e50;
        }
        .stats-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 14px;
        }
        /* Connection Status */
        .connection-status {
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 4px;
            font-weight: bold;
        }
        .status-disconnected {
            background-color: #ffdddd;
            border-left: 4px solid #f44336; /* Red */
            color: #d32f2f;
        }
        .status-connecting {
            background-color: #fffbdd;
            border-left: 4px solid #ffeb3b; /* Yellow */
            color: #fbc02d;
        }
        .status-connected {
            background-color: #ddffdd;
            border-left: 4px solid #4CAF50; /* Green */
            color: #388e3c;
        }
    </style>
    <!-- 添加Font Awesome图标库 -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css">
</head>
<body>
    <!-- 添加导航栏 -->
    <div class="nav-bar">
        <div class="nav-title">Unity Render Streaming 点位选择测试</div>
        <a href="cover.html" class="back-link"><i class="fas fa-arrow-left"></i> 返回封面</a>
    </div>

    <div class="container">
        <!-- Video容器 for Render Streaming -->
        <div class="unity-container">
            <video id="render-stream-video" autoplay playsinline muted>
                Your browser does not support the video tag.
            </video>
            <!-- Render Streaming might overlay its own status indicators here -->
        </div>

        <!-- 控制面板 -->
        <div class="control-panel">
            <h1>控制台</h1>

            <div class="section">
                <h2>连接状态</h2>
                <div id="connection-status" class="connection-status status-disconnected">
                    未连接
                </div>
                <button id="connect-button"> <i class="fas fa-plug"></i> 连接到Unity</button>
                <button id="disconnect-button" disabled> <i class="fas fa-power-off"></i> 断开连接</button>
            </div>

            <!-- Removed Basic Controls Section -->

            <div class="section">
                <h2><i class="fas fa-map-marker-alt"></i> 监测点选择</h2>
                <p>从下拉菜单选择监测点或直接点击下方按钮：</p>
                <select id="point-selector" disabled> <!-- Disable until connected -->
                    <option value="">请选择监测点</option>
                    <!-- Options S1 to S25 -->
                    <option value="S1">S1</option><option value="S2">S2</option><option value="S3">S3</option><option value="S4">S4</option><option value="S5">S5</option>
                    <option value="S6">S6</option><option value="S7">S7</option><option value="S8">S8</option><option value="S9">S9</option><option value="S10">S10</option>
                    <option value="S11">S11</option><option value="S12">S12</option><option value="S13">S13</option><option value="S14">S14</option><option value="S15">S15</option>
                    <option value="S16">S16</option><option value="S17">S17</option><option value="S18">S18</option><option value="S19">S19</option><option value="S20">S20</option>
                    <option value="S21">S21</option><option value="S22">S22</option><option value="S23">S23</option><option value="S24">S24</option><option value="S25">S25</option>
                </select>

                <div class="points-grid">
                    <!-- Grid buttons S1 to S25 -->
                    <div class="point-button" data-point="S1">S1</div><div class="point-button" data-point="S2">S2</div><div class="point-button" data-point="S3">S3</div><div class="point-button" data-point="S4">S4</div><div class="point-button" data-point="S5">S5</div>
                    <div class="point-button" data-point="S6">S6</div><div class="point-button" data-point="S7">S7</div><div class="point-button" data-point="S8">S8</div><div class="point-button" data-point="S9">S9</div><div class="point-button" data-point="S10">S10</div>
                    <div class="point-button" data-point="S11">S11</div><div class="point-button" data-point="S12">S12</div><div class="point-button" data-point="S13">S13</div><div class="point-button" data-point="S14">S14</div><div class="point-button" data-point="S15">S15</div>
                    <div class="point-button" data-point="S16">S16</div><div class="point-button" data-point="S17">S17</div><div class="point-button" data-point="S18">S18</div><div class="point-button" data-point="S19">S19</div><div class="point-button" data-point="S20">S20</div>
                    <div class="point-button" data-point="S21">S21</div><div class="point-button" data-point="S22">S22</div><div class="point-button" data-point="S23">S23</div><div class="point-button" data-point="S24">S24</div><div class="point-button" data-point="S25">S25</div>
                </div>
                 <button id="reset-point-selection" style="margin-top: 10px;" disabled> <i class="fas fa-sync"></i> 重置选择 </button>
            </div>

            <!-- Removed Camera Settings Section -->

            <div class="section">
                <h2><i class="fas fa-chart-line"></i> 统计信息</h2>
                <div class="stats">
                    <div class="stats-title">点位信息</div>
                    <div class="stats-item">
                        <span>当前选中点位:</span>
                        <span id="stat-current-point">无</span>
                    </div>
                    <div class="stats-item">
                        <span>点击次数:</span>
                        <span id="stat-click-count">0</span>
                    </div>
                    <div class="stats-item">
                        <span>最后一次切换时间:</span>
                        <span id="stat-last-switch">-</span>
                    </div>
                </div>
            </div>

            <div class="section">
                <h2><i class="fas fa-exchange-alt"></i> 通信日志</h2>
                <div id="log-container" class="log-container"></div>
                <button id="clear-log" style="margin-top: 10px;">
                    <i class="fas fa-trash"></i> 清除日志
                </button>
            </div>

            <div class="section">
                <h2><i class="fas fa-info-circle"></i> 测试说明</h2>
                <p>此页面用于测试Unity Render Streaming与网页的交互功能：</p>
                <ul>
                    <li>通过按钮连接/断开Render Streaming服务</li>
                    <li>通过下拉菜单或网格按钮选择监测点，发送命令到Unity</li>
                    <li>接收Unity发送的点位选择信息</li>
                </ul>
                <p>所有通信都会记录在上方日志中。</p>
                <p><strong>注意：</strong>确保Unity端配置了Render Streaming，并设置了处理点位聚焦和发送点位选择消息的逻辑。</p>
            </div>
        </div>
    </div>

    <!-- Placeholder for Render Streaming library/scripts -->
    <!-- Example: <script src="render-streaming-library.js"></script> -->
    <!-- Example: <script src="main.js"></script> -->

    <script>
        // 全局变量与状态
        // let unityInstance = null; // No longer using WebGL unityInstance directly
        let peerConnection = null; // WebRTC peer connection
        let dataChannel = null;    // WebRTC data channel
        let clickCount = 0;
        let currentPoint = "";

        // --- UI Element References ---
        const connectButton = document.getElementById('connect-button');
        const disconnectButton = document.getElementById('disconnect-button');
        const pointSelector = document.getElementById('point-selector');
        const pointButtons = document.querySelectorAll('.point-button');
        const logContainer = document.getElementById('log-container');
        const connectionStatusDiv = document.getElementById('connection-status');
        const resetPointButton = document.getElementById('reset-point-selection');
        const videoElement = document.getElementById('render-stream-video');


        // --- Logging ---
        function addLog(message) {
            if (!logContainer) return;
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            const timestamp = new Date().toLocaleTimeString();
            logEntry.textContent = `[${timestamp}] ${message}`;
            logContainer.appendChild(logEntry);
            // Auto-scroll to the bottom
            logContainer.scrollTop = logContainer.scrollHeight;
            // Optional: Limit log entries
            // const maxLogEntries = 100;
            // while (logContainer.children.length > maxLogEntries) {
            //    logContainer.removeChild(logContainer.firstChild);
            // }
        }

        // --- Connection Status UI ---
        function updateConnectionStatus(status, message = '') {
            if (!connectionStatusDiv) return;
            connectionStatusDiv.classList.remove('status-disconnected', 'status-connecting', 'status-connected');
            let statusText = '';

            switch (status) {
                case 'disconnected':
                    connectionStatusDiv.classList.add('status-disconnected');
                    statusText = '未连接';
                    connectButton.disabled = false;
                    disconnectButton.disabled = true;
                    pointSelector.disabled = true;
                    resetPointButton.disabled = true;
                    pointButtons.forEach(btn => btn.style.pointerEvents = 'none'); // Disable grid buttons visually
                    break;
                case 'connecting':
                    connectionStatusDiv.classList.add('status-connecting');
                    statusText = '连接中...';
                    connectButton.disabled = true;
                    disconnectButton.disabled = false; // Allow disconnecting during connection attempt
                    pointSelector.disabled = true;
                    resetPointButton.disabled = true;
                     pointButtons.forEach(btn => btn.style.pointerEvents = 'none');
                    break;
                case 'connected':
                    connectionStatusDiv.classList.add('status-connected');
                    statusText = '已连接';
                    connectButton.disabled = true;
                    disconnectButton.disabled = false;
                    pointSelector.disabled = false; // Enable controls
                    resetPointButton.disabled = false;
                     pointButtons.forEach(btn => btn.style.pointerEvents = 'auto');
                    break;
                 case 'failed':
                    connectionStatusDiv.classList.add('status-disconnected'); // Show as disconnected after failure
                    statusText = '连接失败';
                    connectButton.disabled = false;
                    disconnectButton.disabled = true;
                    pointSelector.disabled = true;
                     resetPointButton.disabled = true;
                    pointButtons.forEach(btn => btn.style.pointerEvents = 'none');
                    break;
                default:
                    statusText = '未知状态';
            }
            connectionStatusDiv.textContent = statusText + (message ? `: ${message}` : '');
        }


        // --- Statistics ---
        function updateStats(pointId) {
            const statCurrentPoint = document.getElementById('stat-current-point');
            const statClickCount = document.getElementById('stat-click-count');
            const statLastSwitch = document.getElementById('stat-last-switch');

            if (pointId !== null && pointId !== undefined) { // Allow empty string for reset
                statCurrentPoint.textContent = pointId || "无"; // Display '无' if pointId is empty string
                 if (pointId) { // Only increment count if a specific point is selected
                    clickCount++;
                    statClickCount.textContent = clickCount;
                 }
                statLastSwitch.textContent = new Date().toLocaleTimeString();

                // Update point button highlight
                pointButtons.forEach(btn => {
                    btn.classList.remove('active');
                });
                 const activeBtn = document.querySelector(`.point-button[data-point="${pointId}"]`);
                 if (activeBtn) {
                    activeBtn.classList.add('active');
                 }

                // Sync dropdown selector
                 if (pointSelector) {
                    pointSelector.value = pointId;
                 }
                 currentPoint = pointId;
            }
        }

        // --- Render Streaming Logic (Placeholders/Core Setup) ---

        // Configuration (replace with your actual signaling server URL)
        const signalingUrl = 'ws://localhost:8888'; // Example URL

        async function connectToUnity() {
            addLog(`尝试连接到信令服务器: ${signalingUrl}`);
            updateConnectionStatus('connecting');

            // --- This is where the complex WebRTC setup happens ---
            // 1. Connect to Signaling Server (using WebSocket)
            // 2. Create RTCPeerConnection
            // 3. Handle ICE candidates (negotiating network paths)
            // 4. Handle SDP Offer/Answer (negotiating media capabilities)
            // 5. Set up video track reception (connect stream to video element)
            // 6. Set up data channel (for sending/receiving messages)
            // --- End of Complex Setup ---

            // ** Placeholder for connection logic **
            // In a real implementation, this would involve WebSocket communication,
            // RTCPeerConnection setup, and event listeners.

            // Simulating connection success/failure for now
            try {
                // TODO: Replace with actual WebRTC connection logic
                addLog("WebRTC 连接逻辑占位符...");
                // Example: Assume connection setup involves async operations
                await new Promise(resolve => setTimeout(resolve, 1500)); // Simulate delay

                // Create Peer Connection (simplified)
                peerConnection = new RTCPeerConnection(); // Add configuration as needed

                 // Setup video track handling
                 peerConnection.ontrack = (event) => {
                     addLog("接收到视频轨道");
                     if (videoElement.srcObject !== event.streams[0]) {
                         videoElement.srcObject = event.streams[0];
                         addLog("视频流已附加到video元素");
                     }
                 };

                // Setup Data Channel (example for receiving)
                peerConnection.ondatachannel = (event) => {
                    addLog("接收到数据通道");
                    dataChannel = event.channel;
                    setupDataChannelListeners(dataChannel);
                };

                 // If creating the data channel initiator side (often the browser):
                 // dataChannel = peerConnection.createDataChannel("unityDataChannel");
                 // setupDataChannelListeners(dataChannel);
                 // addLog("数据通道已创建");

                 // TODO: Add SDP offer/answer and ICE candidate exchange logic here
                 // This usually involves the signaling server


                // Assuming the above steps (signaling, SDP, ICE) complete successfully...
                // We need to wait for the data channel to open
                 if (dataChannel) { // Check if dataChannel was created/received
                    await waitForDataChannelOpen(dataChannel);
                    updateConnectionStatus('connected');
                    addLog("成功连接到Unity并通过数据通道通信");
                 } else {
                     // If data channel wasn't established during setup (might happen if connection fails early)
                     throw new Error("未能建立数据通道");
                 }


            } catch (error) {
                addLog(`连接失败: ${error.message}`);
                updateConnectionStatus('failed', error.message);
                disconnectFromUnity(); // Clean up partially formed connection
            }
        }

         function waitForDataChannelOpen(channel) {
             return new Promise((resolve, reject) => {
                 // If already open, resolve immediately
                 if (channel.readyState === 'open') {
                     resolve();
                     return;
                 }
                 // Check periodically
                 const interval = setInterval(() => {
                     if (channel.readyState === 'open') {
                         clearInterval(interval);
                         resolve();
                     } else if (channel.readyState === 'closed' || channel.readyState === 'closing') {
                         clearInterval(interval);
                         reject(new Error("数据通道在打开前关闭"));
                     }
                 }, 100); // Check every 100ms
                 // Timeout after a reasonable period
                 setTimeout(() => {
                     clearInterval(interval);
                     if (channel.readyState !== 'open') {
                         reject(new Error("等待数据通道打开超时"));
                     }
                 }, 10000); // 10 second timeout
             });
         }


        function setupDataChannelListeners(channel) {
            channel.onopen = () => {
                addLog("数据通道已打开");
                // Connection is truly ready now (or confirmed ready)
                // updateConnectionStatus('connected'); // Might be better to set connected status after open
            };

            channel.onclose = () => {
                addLog("数据通道已关闭");
                // Handle potential disconnection
                updateConnectionStatus('disconnected', '数据通道关闭');
                disconnectFromUnity(); // Trigger cleanup
            };

            channel.onerror = (error) => {
                addLog(`数据通道错误: ${error}`);
                 updateConnectionStatus('failed', `数据通道错误: ${error}`);
                 disconnectFromUnity(); // Trigger cleanup on error
            };

            channel.onmessage = (event) => {
                try {
                    const message = JSON.parse(event.data);
                    addLog(`收到消息: ${JSON.stringify(message)}`);

                    // --- Handle messages FROM Unity ---
                    if (message.type === 'pointSelected') {
                        unitySendSelectedPoint(message.pointId); // Call existing handler
                    }
                    // Add more message types from Unity if needed

                } catch (e) {
                    addLog(`处理接收到的消息时出错 (非JSON?): ${event.data}`);
                }
            };
        }

        function disconnectFromUnity() {
            addLog("断开连接...");
            if (dataChannel) {
                dataChannel.close();
                dataChannel = null;
            }
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            // TODO: Disconnect from signaling server if needed
            if (videoElement) {
                 videoElement.srcObject = null; // Clear video stream
            }
            addLog("连接已断开");
            updateConnectionStatus('disconnected');
        }


        // --- Sending Messages via Data Channel ---
        function sendMessageToUnity(messageObject) {
            if (dataChannel && dataChannel.readyState === 'open') {
                try {
                    const messageString = JSON.stringify(messageObject);
                    addLog(`发送消息: ${messageString}`);
                    dataChannel.send(messageString);
                } catch (e) {
                    addLog(`序列化消息时出错: ${e}`);
                }
            } else {
                addLog("数据通道未打开或不可用，无法发送消息");
            }
        }

        // --- Point Selection Logic (Modified for Data Channel) ---

        // 聚焦Unity视图到指定点位 (MODIFIED)
        function focusUnityViewOnPoint(pointId) {
            // ** REPLACED SendMessage with data channel **
            addLog(`通过数据通道发送焦点命令: ${pointId}`);
             sendMessageToUnity({
                 type: 'focusPoint', // Define a message type
                 pointId: pointId
             });
        }

        // 从Unity接收点位选择的函数 (Now triggered by data channel message handler)
        window.unitySendSelectedPoint = function(pointId) {
            addLog(`Unity选中了点位 (通过数据通道): ${pointId}`);
            updateStats(pointId);
        };


        // --- Event Listener Setup ---
        function initControlPanelEvents() {
             // Connection Buttons
             connectButton.addEventListener('click', connectToUnity);
             disconnectButton.addEventListener('click', disconnectFromUnity);


            // Initialize Point Selector (Dropdown)
             if (pointSelector) {
                pointSelector.addEventListener('change', function() {
                    const pointId = this.value;
                    if (pointId) {
                        addLog(`通过选择器选择监测点: ${pointId}`);
                        focusUnityViewOnPoint(pointId);
                        updateStats(pointId);
                    } else {
                         // Handle "Please select" option if needed, maybe reset view?
                         // addLog("选择器已重置");
                         // sendMessageToUnity({ type: 'resetView' }); // Example reset message
                         // updateStats("");
                    }
                });
            }

            // Initialize Point Grid Buttons
             pointButtons.forEach(button => {
                 button.addEventListener('click', function() {
                    if (connectionStatusDiv.classList.contains('status-connected')) { // Only allow clicks when connected
                        const pointId = this.getAttribute('data-point');
                        addLog(`通过网格按钮选择监测点: ${pointId}`);
                        focusUnityViewOnPoint(pointId);
                        updateStats(pointId);
                    } else {
                        addLog("请先连接到Unity");
                    }
                 });
            });
             
            // Reset Button
            resetPointButton.addEventListener('click', () => {
                 addLog("重置点位选择");
                 sendMessageToUnity({ type: 'resetView' }); // Assuming a resetView message type
                 updateStats(""); // Update UI to show no selection
            });

            // Log Clear Button
            document.getElementById('clear-log').addEventListener('click', () => {
                if (logContainer) {
                    logContainer.innerHTML = '';
                }
                addLog("日志已清除");
            });
        }


        // --- Page Load ---
        document.addEventListener('DOMContentLoaded', () => {
            addLog("页面已加载，等待连接...");
            updateConnectionStatus('disconnected'); // Set initial state
            initControlPanelEvents(); // Setup button listeners etc.
            // Removed automatic WebGL loadUnityGame() call
        });

    </script>
</body>
</html> 